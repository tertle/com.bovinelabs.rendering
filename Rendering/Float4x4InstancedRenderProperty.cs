// <copyright file="Float4x4InstancedRenderProperty.cs" company="BovineLabs">
//     Copyright (c) BovineLabs. All rights reserved.
// </copyright>
// <auto-generated>It's not, just don't want analyzers working on this file atm.</auto-generated>

namespace BovineLabs.Systems.Rendering
{
    using System;
    using System.Runtime.InteropServices;
    using Unity.Collections;
    using Unity.Collections.LowLevel.Unsafe;
    using Unity.Entities;
    using Unity.Jobs;
    using Unity.Mathematics;
    using UnityEngine;
    using UnityEngine.Assertions;

    public abstract unsafe class Float4x4InstancedRenderProperty<T> : InstancedRenderProperty<T, float4x4>
        where T : struct, IInstancedRenderProperty<float4x4>
    {
        private GCHandle handle;
        private Matrix4x4[] managedData;

        private int lastWrite;

        protected Float4x4InstancedRenderProperty()
        {
            this.managedData = new Matrix4x4[1023];
            this.handle = GCHandle.Alloc(this.managedData, GCHandleType.Pinned);
            var ptr = this.handle.AddrOfPinnedObject().ToPointer();
            this.Data = NativeArrayUnsafeUtility.ConvertExistingDataToNativeArray<float4x4>(ptr, this.managedData.Length, Allocator.Invalid);
#if ENABLE_UNITY_COLLECTIONS_CHECKS
            NativeArrayUnsafeUtility.SetAtomicSafetyHandle(ref this.Data, AtomicSafetyHandle.Create());
#endif
        }

        public override void Dispose()
        {
            this.handle.Free();
            this.managedData = Array.Empty<Matrix4x4>();
            base.Dispose();
        }

        public override void AddData(in ArchetypeChunk chunk, in NativeArray<VisibleIndex> visible, int instanceStart, int copyCount)
        {
            var chunkData = chunk.GetNativeArray(this.ArchetypeType);
            if (chunkData.Length == 0)
                return;

            if (this.lastWrite < instanceStart)
                this.Fill(this.lastWrite, instanceStart - this.lastWrite);
            this.lastWrite = instanceStart + copyCount;

            Assert.IsTrue(copyCount <= math.min(this.Data.Length - instanceStart, chunkData.Length));

            var src = new NativeSlice<T>(chunkData).SliceConvert<float4x4>();
            var dest = new NativeSlice<float4x4>(this.Data, instanceStart, copyCount);

            new CopyJob
                {
                    Visibile = visible,
                    Source = src,
                    Dest = dest,
                }
                .Schedule().Complete();

            /*var src = new NativeSlice<T>(chunkData, 0, copyCount);
            var dest = new NativeSlice<float4x4>(this.Data, instanceStart, copyCount);
            UnsafeUtility.MemCpy(dest.GetUnsafePtr(), src.GetUnsafeReadOnlyPtr(), src.Length * UnsafeUtility.SizeOf<T>());*/
        }

        public override void ApplyAndFree(MaterialPropertyBlock block, int instanceCount)
        {
            if (this.lastWrite == 0)
                return;

            if (this.lastWrite < instanceCount)
                this.Fill(this.lastWrite, instanceCount - this.lastWrite);
            this.lastWrite = 0;

            var header = GetHeader(this.handle.AddrOfPinnedObject().ToPointer());
            var originalLength = header->length;
            try
            {
                header->length = (UIntPtr) instanceCount;
                block.SetMatrixArray(NameId, this.managedData);
            }
            finally
            {
                header->length = originalLength;
            }
        }

        public override void ApplyPerInstance(MaterialPropertyBlock block, int index)
        {
            if (this.lastWrite < index)
                block.SetMatrix(NameId, this.DefaultValue);
            else
                block.SetMatrix(NameId, this.managedData[index]);
        }

        public override bool FetchDefault(Material material)
        {
            if (!material.HasProperty(NameId))
            {
                this.DefaultValue = default;
                return false;
            }

            this.DefaultValue = material.GetMatrix(NameId);
            return true;
        }
    }
}
