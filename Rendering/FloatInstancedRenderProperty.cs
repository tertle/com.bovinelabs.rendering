// <copyright file="FloatInstancedRenderProperty.cs" company="BovineLabs">
//     Copyright (c) BovineLabs. All rights reserved.
// </copyright>
// <auto-generated>It's not, just don't want analyzers working on this file atm.</auto-generated>

namespace BovineLabs.Systems.Rendering
{
    using System;
    using System.Runtime.InteropServices;
    using Unity.Collections;
    using Unity.Collections.LowLevel.Unsafe;
    using Unity.Entities;
    using Unity.Jobs;
    using Unity.Mathematics;
    using UnityEngine;
    using UnityEngine.Assertions;

    /// <summary>
    /// Float instanced render property.
    /// </summary>
    /// <typeparam name="T">The unmanaged type.</typeparam>
    public unsafe class FloatInstancedRenderProperty<T> : InstancedRenderProperty<T, float>
        where T : struct, IInstancedRenderProperty<float>
    {
        private GCHandle handle;
        private float[] managedData;

        private int lastWrite;

        /// <summary>
        /// Initializes a new instance of the <see cref="FloatInstancedRenderProperty{T}"/> class.
        /// </summary>
        public FloatInstancedRenderProperty()
        {
            this.managedData = new float[1023];
            this.handle = GCHandle.Alloc(this.managedData, GCHandleType.Pinned);
            var ptr = this.handle.AddrOfPinnedObject().ToPointer();
            this.Data = NativeArrayUnsafeUtility.ConvertExistingDataToNativeArray<float>(ptr, this.managedData.Length, Allocator.Invalid);
#if ENABLE_UNITY_COLLECTIONS_CHECKS
            NativeArrayUnsafeUtility.SetAtomicSafetyHandle(ref this.Data, AtomicSafetyHandle.Create());
#endif
        }

        /// <inheritdoc/>
        public override void Dispose()
        {
            this.handle.Free();
            this.managedData = Array.Empty<float>();
            base.Dispose();
        }

        /// <inheritdoc/>
        public override void AddData(in ArchetypeChunk chunk, in NativeArray<VisibleIndex> visible, int instanceStart, int copyCount)
        {
            var chunkData = chunk.GetNativeArray(this.ArchetypeType);
            if (chunkData.Length == 0)
            {
                return;
            }

            if (this.lastWrite < instanceStart)
            {
                this.Fill(this.lastWrite, instanceStart - this.lastWrite);
            }

            this.lastWrite = instanceStart + copyCount;

            Assert.IsTrue(copyCount <= math.min(this.Data.Length - instanceStart, chunkData.Length));

            /*var src = new NativeSlice<T>(chunkData, 0, copyCount);

            var p = src.GetUnsafeReadOnlyPtr();

            for (var i = 0; i < chunkData.Length; i++)
            {
                //Debug.Log(src[i));
                Debug.Log(UnsafeUtility.ReadArrayElementWithStride<T>(p, i, UnsafeUtility.SizeOf<T>()));
            }


            var dest = new NativeSlice<float>(this.Data, instanceStart, copyCount);
            UnsafeUtility.MemCpy(dest.GetUnsafePtr(), src.GetUnsafeReadOnlyPtr(), src.Length * UnsafeUtility.SizeOf<T>());*/

            var src = new NativeSlice<T>(chunkData).SliceConvert<float>();
            var dest = new NativeSlice<float>(this.Data, instanceStart, copyCount);

            new CopyJob
                {
                    Visibile = visible,
                    Source = src,
                    Dest = dest,
                }
                .Schedule().Complete();
        }

        /// <inheritdoc/>
        public override void ApplyAndFree(MaterialPropertyBlock block, int instanceCount)
        {
            if (this.lastWrite == 0)
            {
                return;
            }

            if (this.lastWrite < instanceCount)
            {
                this.Fill(this.lastWrite, instanceCount - this.lastWrite);
            }

            this.lastWrite = 0;

            var header = GetHeader(this.handle.AddrOfPinnedObject().ToPointer());
            var originalLength = header->length;
            try
            {
                header->length = (UIntPtr)instanceCount;
                block.SetFloatArray(NameId, this.managedData);
            }
            finally
            {
                header->length = originalLength;
            }
        }

        /// <inheritdoc/>
        public override void ApplyPerInstance(MaterialPropertyBlock block, int index)
        {
            if (this.lastWrite < index)
            {
                block.SetFloat(NameId, this.DefaultValue);
            }
            else
            {
                block.SetFloat(NameId, this.managedData[index]);
            }
        }

        /// <inheritdoc/>
        public override bool FetchDefault(Material material)
        {
            if (!material.HasProperty(NameId))
            {
                this.DefaultValue = default;
                return false;
            }

            this.DefaultValue = material.GetFloat(NameId);
            return true;
        }
    }
}