// <copyright file="InstancedRenderProperty.cs" company="BovineLabs">
//     Copyright (c) BovineLabs. All rights reserved.
// </copyright>
// <auto-generated>It's not, just don't want analyzers working on this file atm.</auto-generated>

namespace BovineLabs.Systems.Rendering
{
    using System;
    using System.Diagnostics.CodeAnalysis;
    using System.Runtime.InteropServices;
    using Unity.Burst;
    using Unity.Collections;
    using Unity.Collections.LowLevel.Unsafe;
    using Unity.Entities;
    using Unity.Jobs;
    using Unity.Mathematics;
    using UnityEngine;
    using UnityEngine.Assertions;

    public interface IInstancedRenderProperty<T> : IComponentData
        where T : struct
    {
    }

    public interface IFloatInstancedRenderProperty : IInstancedRenderProperty<float>
    {
    }

    public interface IFloat4InstancedRenderProperty : IInstancedRenderProperty<float4>
    {
    }

    public interface IFloat4x4InstancedRenderProperty : IInstancedRenderProperty<float4x4>
    {
    }

    public interface IColorInstancedRenderProperty : IInstancedRenderProperty<Color>
    {
    }

    public abstract class InstancedRenderPropertyBase : IDisposable
    {
        public abstract bool Exists(in ArchetypeChunk chunk);

        public abstract void FetchArchetypeType(ComponentSystemBase system);

        public abstract void AddData(in ArchetypeChunk chunk, in NativeArray<VisibleIndex> visible, int instanceStart, int copyCount);

        public abstract bool FetchDefault(Material material);

        public abstract void ApplyAndFree(MaterialPropertyBlock block, int instanceCount);

        public abstract void ApplyPerInstance(MaterialPropertyBlock block, int index);

        /// <inheritdoc/>
        public abstract void Dispose();
    }

    [SuppressMessage("ReSharper", "StaticMemberInGenericType", Justification = "Intended")]
    public abstract class InstancedRenderProperty<T, TU> : InstancedRenderPropertyBase
        where T : struct, IInstancedRenderProperty<TU>
        where TU : struct
    {
        static InstancedRenderProperty()
        {
            var componentType = typeof(T);
            var name = componentType.Name;

            if (name.EndsWith("InstancedProperty"))
            {
                name = name.Substring(0, name.Length - "InstancedProperty".Length);
            }

            if (name.EndsWith("RenderProperty"))
            {
                name = name.Substring(0, name.Length - "RenderProperty".Length);
            }

            if (name.EndsWith("Property"))
            {
                name = name.Substring(0, name.Length - "Property".Length);
            }

            if (!name.StartsWith("_"))
            {
                name = "_" + name;
            }

            NameId = Shader.PropertyToID(name);

            Assert.IsTrue(UnsafeUtility.SizeOf<T>() == UnsafeUtility.SizeOf<TU>(), "Component must only contain the actual property value");
        }

        protected static int NameId { get; }

        protected ArchetypeChunkComponentType<T> ArchetypeType { get; private set; }

        protected TU DefaultValue { get; set; }

        protected NativeArray<TU> Data;

        public override bool Exists(in ArchetypeChunk chunk)
        {
            return chunk.GetNativeArray(this.ArchetypeType).Length > 0;
        }

        public override void FetchArchetypeType(ComponentSystemBase system)
        {
            this.ArchetypeType = system.GetArchetypeChunkComponentType<T>();
        }

        public override void Dispose()
        {
        }

        protected static unsafe ArrayHeader* GetHeader(void* pBytes)
        {
            return (ArrayHeader*)pBytes - 1;
        }

        protected void Fill(int start, int count)
        {
            var dest = new NativeSlice<TU>(this.Data, start, count);
            for (var i = 0; i < dest.Length; i++)
            {
                dest[i] = this.DefaultValue;
            }
        }

        [BurstCompile]
        protected struct CopyJob : IJob
        {
            [ReadOnly]
            public NativeArray<VisibleIndex> Visibile;

            public NativeSlice<TU> Source;
            public NativeSlice<TU> Dest;

            /// <inheritdoc />
            public void Execute()
            {
                for (var index = 0; index < this.Dest.Length; index++)
                {
                    this.Dest[index] = this.Source[this.Visibile[index].Value];
                }
            }
        }
    }

    [StructLayout(LayoutKind.Sequential, Pack = 1)]
    public struct ArrayHeader
    {
        public UIntPtr type;
        public UIntPtr length;
    }
}